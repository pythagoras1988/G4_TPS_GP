from mpi4py import MPI
import numpy as np
import os
import shutil
import subprocess

class InitMPI:
    def __init__(self):
        self.comm = MPI.COMM_WORLD
        self.size = self.comm.Get_size()
        self.rank = self.comm.Get_rank()
        # Only process 0 do the printing
        if self.rank == 0:
            print('Initializing MPI mode for %d processes' %self.size)
        if self.size>1:
            self.MPImode = True
        else:
            self.MPImode = False

        # Generating all the relevant files for each process
        self._generateInputFilePerProcess()
        self._generateOutputFilePerProcess()

    def get_num_processes(self):
        return self.size

    def get_rank_processes(self):
        return self.rank

    # Generate individual mac file for each process
    def _generateInputFilePerProcess(self):
        fname = 'hadron_therapy' + str(self.rank) + '.mac'
        if os.path.isfile(fname):
            os.remove(fname)
            shutil.copyfile('hadron_therapy.mac',fname)
        else:
            shutil.copyfile('hadron_therapy.mac',fname)

    #Generate individual dose.out file for each process
    def _generateOutputFilePerProcess(self):
        fname = 'Dose' + str(self.rank) + '.out'
        if os.path.isfile(fname):
            os.remove(fname)

    def reduceData(self):
        pass

    def runG4PerProcess(self):
        fname = 'hadron_therapy' + str(self.rank) + '.mac'
        # run G4 for each energy layer
        if self.MPImode:
            subprocess.call(["./hadrontherapy", fname]);

    @staticmethod
    def scheduler_simple(energyInfo,totalEnergyLayers,size):
        return {k : k%size for k in range(totalEnergyLayers)}

    @staticmethod
    def scheduler_equal_load(energyInfo,totalEnergyLayers,size):
        return {k : k%size for k in range(totalEnergyLayers)}

    # Clear all files generated by processes
    def destructor(self):
        if self.MPImode:
            fname1 = 'hadron_therapy' + str(self.rank) + '.mac'
            fname2 = 'Dose' + str(self.rank) + '.out'
            try:
                os.remove(fname1)
                os.remove(fname2)
            except:
                raise exception('The input and output files by the processes do not exists...')
